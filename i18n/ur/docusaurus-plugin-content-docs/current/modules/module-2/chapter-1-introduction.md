---
title: "چیپٹر 1: سیمولیشن ماحول کا تعارف"
sidebar_label: "چیپٹر 1: سیمولیشن ماحول کا تعارف"
---

# چیپٹر 1: سیمولیشن ماحول کا تعارف

## جائزہ

یہ چیپٹر روبوٹکس سیمولیشن ماحول کے بنیادی تصورات کو متعارف کراتا ہے، جس میں فزکس سیمولیشن کے لیے جیزبو اور زیادہ معیار کے رینڈرنگ کے لیے یونیٹی کو بنیادی پلیٹ فارمز کے طور پر مرکوز کیا گیا ہے۔ آپ سیکھیں گے کہ روبوٹکس ترقی میں سیمولیشن کی کیا اہمیت ہے، سیمولیشن ماحول کی مختلف اقسام، اور وہ ROS 2 کے ساتھ کیسے ضم ہوتے ہیں۔ یہ بنیادی علم آپ کو بعد کے چیپٹرز میں جامع ڈیجیٹل ٹوئن ماحول تیار کرنے کے لیے تیار کرے گا۔

سیمولیشن ماحول جدید روبوٹکس میں ضروری اوزار ہیں، جو روبوٹکس سسٹم کی ترقی، ٹیسٹنگ، اور توثیق کے لیے محفوظ، قیمت کے لحاظ سے مؤثر، اور کارآمد پلیٹ فارمز فراہم کرتے ہیں۔ وہ تیز پروٹو ٹائپنگ، الگورتھم کی ترقی، اور سسٹم انضمام کو فعال کرتے ہیں جسمانی ہارڈ ویئر سے منسلک پابندیوں اور خطرات کے بغیر۔ مختلف سیمولیشن پلیٹ فارمز کے اصول اور صلاحیتوں کو سمجھنا روبوٹکس کی مؤثر ترقی کے لیے اہم ہے۔

## سیکھنے کے اہداف

- روبوٹکس ترقی میں سیمولیشن کے کردار اور اہمیت کو سمجھنا
- سیمولیشن ماحول کی مختلف اقسام اور ان کے استعمال کے معاملات کا موازنہ کرنا
- جیزبو فزکس سیمولیشن کے بنیادی تصورات سیکھنا
- زیادہ معیار کے رینڈرنگ اور وژولائزیشن کے لیے یونیٹی کی صلاحیتوں کو تلاش کرنا
- سیمولیشن ماحول کو ROS 2 کے ساتھ ضم کرنے کو سمجھنا
- سیمولیشن پر مبنی ترقی کے فوائد اور حدود کی شناخت کرنا

## کلیدی تصورات

### سیمولیشن ماحول کی اقسام

سیمولیشن ماحول کو ان کے بنیادی مرکز کی بنیاد پر درجہ بند کیا جا سکتا ہے: فزکس سیمولیشن (جیزبو)، وژوئل رینڈرنگ (یونیٹی)، یا ہائبرڈ نقطہ نظر جو دونوں کو جوڑتا ہے۔ ہر قسم روبوٹکس ترقی کی پائپ لائن میں مختلف مقاصد کے لیے کام کرتا ہے۔

### فزکس سیمولیشن بمقابلہ وژوئل سیمولیشن

فزکس سیمولیشن جسمانی بات چیت، قوتیں، اور ڈائنامکس کی درست ماڈلنگ پر مرکوز ہوتا ہے، جبکہ وژوئل سیمولیشن حقیقی رینڈرنگ اور ظہور پر زور دیتا ہے۔ جامع روبوٹکس سیمولیشن کے لیے دونوں ضروری ہیں۔

### ڈیجیٹل ٹوئن تصور

ڈیجیٹل ٹوئن جسمانی سسٹم کا ایک ورچوئل نمونہ ہے جو سیمولیشن، تجزیات، اور بہتری کو فعال کرتا ہے۔ روبوٹکس میں، ڈیجیٹل ٹوئن سیمولیشن اور حقیقت کے درمیان پُل کا کام کرتا ہے، جو محفوظ ٹیسٹنگ اور توثیق کی اجازت دیتا ہے۔

### سیمولیشن کی معیاریت

سیمولیشن کی معیاریت یہ بتاتی ہے کہ کتنا درست طریقے سے ایک سیمولیشن حقیقی دنیا کی نمائندگی کرتا ہے۔ زیادہ معیاری سیمولیشن زیادہ حقیقی رویہ فراہم کرتا ہے لیکن زیادہ کمپیو ٹیشنل وسائل کی ضرورت ہوتی ہے۔

## تکنیکی گہرائی

### روبوٹکس میں سیمولیشن کا کردار

سیمولیشن روبوٹکس ترقی میں متعدد اہم کردار ادا کرتا ہے:

**الگورتھم کی ترقی**: سیمولیشن نئے الگورتھم کو ٹیسٹ کرنے کے لیے ایک محفوظ ماحول فراہم کرتا ہے جہاں مہنگے ہارڈ ویئر یا انسانوں کو خطرے کے بغیر تجربہ کیا جا سکتا ہے۔ محققین نویل نقطہ نظر کے ساتھ تجربہ کر سکتے ہیں اور جلدی سے دہرائی کر سکتے ہیں۔

**سسٹم انضمام**: متعدد اجزاء والے پیچیدہ روبوٹکس سسٹم کو جسمانی ہارڈ ویئر پر ڈپلائمنٹ سے پہلے سیمولیشن میں ضم اور ٹیسٹ کیا جا سکتا ہے۔

**ٹریننگ ڈیٹا جنریشن**: AI اور مشین لرننگ ایپلی کیشنز کے لیے، سیمولیشن وسیع مقدار میں متنوع ٹریننگ ڈیٹا تیار کر سکتا ہے جو حقیقی دنیا میں جمع کرنا مشکل یا ناممکن ہو سکتا ہے۔

**حفاطت کی توثیق**: ریل ورلڈ ماحول میں روبوٹس کو ڈپلائے کرنے سے پہلے، سیمولیشن حفاظتی اہم رویوں اور ناکامی کے نمونوں کی مکمل ٹیسٹنگ کی اجازت دیتا ہے۔

### جیزبو بمقابلہ یونیٹی: مکمل کرنے والے نقطہ نظر

جیزبو اور یونیٹی روبوٹکس سیمولیشن میں مکمل کرنے والے کردار ادا کرتے ہیں:

**جیزبو کی مضبوطیاں**:
- متعدد انجن اختیارات (ODE، بُلیٹ، DART) کے ساتھ درست فزکس سیمولیشن
- حقیقی تصادم کا پتہ لگانا اور رابطہ کی قوتیں
- پلگ انز کے ذریعے ROS/ROS 2 کے ساتھ انضمام
- سینسرز کی وسیع رینج (LiDAR، کیمرے، IMUs) کی حمایت
- اوپن سورس اور روبوٹکس تحقیق میں وسیع پیمانے پر اپنایا گیا

**یونیٹی کی مضبوطیاں**:
- اعلی معیار کے وژوئل رینڈرنگ کے ساتھ اعلی درجے کی لائٹنگ اور مواد
- ورچوئل اور اضافہ شدہ حقیقت کی حمایت
- طاقتور وژولائزیشن اور ڈیبگنگ ٹولز
- وسیع اثاثہ لائبریری اور ترقی کا ماحول
- حقیقی وقت رینڈرنگ کی صلاحیتیں

### سیمولیشن معماری (متن ڈائیگرام)

```
+-----------------------------------------------------------+
|                 سیمولیشن ماحول                           |
|                                                           |
|  +----------------+    +----------------+    +----------+ |
|  |   حقیقی روبوٹ  |    |   جیزبو        |    |   یونیٹی | |
|  |   (جسمانی      |<-->|   فزکس         |<-->|   وژوئل | |
|  |   سسٹم)        |    |   سیمولیشن     |    |   لیئر  | |
|  +----------------+    +----------------+    +----------+ |
|         |                       |                    |    |
|         | حقیقی وقت ڈیٹا       | سینسر ڈیٹا        | وژوئل
|         | اور کمانڈز            | اور فزکس          | فیڈ بیک
|         v                       v                    v    |
|  +----------------+    +----------------+    +----------+ |
|  |   ROS 2        |<-->|   سیمولیشن     |<-->|   انسان  | |
|  |   مڈل ویئر     |    |   برج          |    |   صارف   | |
|  |   لیئر         |    |                |    |   (VR/AR) | |
|  +----------------+    +----------------+    +----------+ |
|         |                       |                    |    |
|         v                       v                    v    |
|  +----------------+    +----------------+    +----------+ |
|  | روبوٹک         |    | ادراک اور       |    | ٹریننگ | |
|  | کنٹرول         |    | AI الگورتھم    |    | ڈیٹا     | |
|  | الگورتھم       |    | (CV، ML، وغیرہ)|    | جنریشن | |
|  +----------------+    +----------------+    +----------+ |
+-----------------------------------------------------------+
```

### سیمولیشن کی معیاریت کے تنازعات

سیمولیشن کی معیاریت کے مختلف درجے مختلف مقاصد کے لیے کام کرتے ہیں:

**کم معیاریت**: الگورتھم کی ترقی اور بنیادی ٹیسٹنگ کے لیے تیز، سادہ سیمولیشن
**متوسط معیاریت**: سسٹم انضمام اور معتدل پیچیدگی ٹیسٹنگ کے لیے متوازن سیمولیشن
**زیادہ معیاریت**: حتمی توثیق اور ٹریننگ ڈیٹا جنریشن کے لیے تفصیلی سیمولیشن

## کوڈ کی مثالیں

### بنیادی جیزبو ورلڈ فائل

```xml
<?xml version="1.0" ?>
<sdf version="1.7">
  <world name="simple_world">
    <!-- فزکس انجن کنفیگریشن -->
    <physics type="ode">
      <gravity>0 0 -9.8</gravity>
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1.0</real_time_factor>
      <real_time_update_rate>1000.0</real_time_update_rate>
    </physics>

    <!-- معیاری ماڈلز شامل کریں -->
    <include>
      <uri>model://sun</uri>
    </include>

    <include>
      <uri>model://ground_plane</uri>
    </include>

    <!-- سادہ باکس آبجیکٹ -->
    <model name="simple_box">
      <pose>2 0 0.5 0 0 0</pose>
      <link name="link">
        <inertial>
          <mass>1.0</mass>
          <inertia>
            <ixx>0.166667</ixx>
            <ixy>0</ixy>
            <ixz>0</ixz>
            <iyy>0.166667</iyy>
            <iyz>0</iyz>
            <izz>0.166667</izz>
          </inertia>
        </inertial>
        <collision name="collision">
          <geometry>
            <box>
              <size>1 1 1</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>1 1 1</size>
            </box>
          </geometry>
          <material>
            <ambient>0.8 0.6 0.4 1</ambient>
            <diffuse>0.8 0.6 0.4 1</diffuse>
          </material>
        </visual>
      </link>
    </model>

  </world>
</sdf>
```

### بنیادی یونیٹی روبوٹ وژولائزیشن (تصوراتی)

```csharp
// یہ ایک تصوراتی مثال ہے کہ یونیٹی روبوٹ کو کیسے دکھا سکتی ہے
using UnityEngine;
using Unity.Robotics.ROSTCPConnector;
using RosMessageTypes.Sensor;

public class RobotVisualizer : MonoBehaviour
{
    [Header("روبوٹ لنکس")]
    public GameObject baseLink;
    public GameObject link1;
    public GameObject link2;

    private ROSTCPConnector ros;
    private MessageSubscriber jointStateSubscriber;

    void Start()
    {
        ros = ROSTCPConnector.instance;
        // ROS سے جوائنٹ اسٹیٹس کو سبسکرائب کریں
        ros.Subscribe<SensorJointStateMsg>("/joint_states", OnJointStateReceived);
    }

    void OnJointStateReceived(SensorJointStateMsg jointStateMsg)
    {
        // جوائنٹ اسٹیٹس کی بنیاد پر روبوٹ وژولائزیشن کو اپ ڈیٹ کریں
        for (int i = 0; i < jointStateMsg.name.Count; i++)
        {
            string jointName = jointStateMsg.name[i];
            float jointPosition = (float)jointStateMsg.position[i];

            // جوائنٹ پوزیشن کی بنیاد پر متعلقہ لنک کو اپ ڈیٹ کریں
            UpdateLink(jointName, jointPosition);
        }
    }

    void UpdateLink(string jointName, float position)
    {
        // جوائنٹ پوزیشنز کی بنیاد پر روبوٹ کی وژوئل نمائندگی کو اپ ڈیٹ کریں
        switch (jointName)
        {
            case "joint1":
                if (link1 != null)
                    link1.transform.localRotation = Quaternion.Euler(0, position * Mathf.Rad2Deg, 0);
                break;
            case "joint2":
                if (link2 != null)
                    link2.transform.localRotation = Quaternion.Euler(0, position * Mathf.Rad2Deg, 0);
                break;
        }
    }
}
```

### ROS 2 انضمام کی مثال

```python
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import JointState
from std_msgs.msg import Header
import math

class SimulationBridgeNode(Node):
    """نیا جو سیمولیشن اور ROS 2 کو جوڑتا ہے"""

    def __init__(self):
        super().__init__('simulation_bridge_node')

        # جوائنٹ اسٹیٹس کے لیے شائع کنندہ
        self.joint_state_publisher = self.create_publisher(
            JointState, '/joint_states', 10)

        # جوائنٹ اسٹیٹس شائع کرنے کے لیے ٹائمر
        self.timer = self.create_timer(0.05, self.publish_joint_states)

        # سیمولیٹڈ جوائنٹ پوزیشنز
        self.time = 0.0
        self.joint_names = ['joint1', 'joint2', 'joint3']

        self.get_logger().info('سیمولیشن برج نوڈ انشائیلائز ہوا')

    def publish_joint_states(self):
        """سیمولیٹڈ جوائنٹ اسٹیٹس شائع کریں"""
        msg = JointState()
        msg.header = Header()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.name = self.joint_names

        # اوسیلیٹنگ جوائنٹ پوزیشنز کو سیمولیٹ کریں
        self.time += 0.05
        msg.position = [
            math.sin(self.time) * 0.5,
            math.cos(self.time * 1.3) * 0.3,
            math.sin(self.time * 0.7) * 0.8
        ]

        # ضرورت پڑنے پر رفتار اور کوششیں شامل کریں
        msg.velocity = [0.0] * len(msg.position)
        msg.effort = [0.0] * len(msg.position)

        self.joint_state_publisher.publish(msg)

def main(args=None):
    rclpy.init(args=args)
    node = SimulationBridgeNode()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info('سیمولیشن برج نوڈ بند ہو گیا')
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## عام مسائل

- **حقیقت کا فرق**: سیمولیشن اور حقیقت کے درمیان فرق الگورتھم کو نقصان پہنچا سکتا ہے جو سیمولیشن میں کام کرتے ہیں لیکن حقیقی دنیا میں ناکام ہو جاتے ہیں
- **کمپیو ٹیشنل پیچیدگی**: زیادہ معیاری سیمولیشن کمپیو ٹیشنل طور پر مہنگا اور سست ہو سکتا ہے
- **ماڈل کی غلطی**: غلط روبوٹ یا ماحول کے ماڈل غلط سیمولیشن کے نتائج کا سبب بن سکتے ہیں
- **انضمام کے چیلنج**: ROS 2 کے ساتھ مختلف سیمولیشن ٹولز کو جوڑنا پیچیدہ اور غلطی سے بھرا ہو سکتا ہے
- **توثیق کی ضروریات**: سیمولیشن کے نتائج کو حقیقی دنیا کے ڈیٹا کے ساتھ احتیاط سے توثیق کرنا ضروری ہے

## چیک پوائنٹس / مینی ایکسائزز

1. جیزبو انسٹال کریں اور بنیادی مثالوں کے ساتھ یہ تصدیق کریں کہ یہ کام کرتا ہے
2. یونیٹی روبوٹکس پیکیج تلاش کریں اور ایک بنیادی منظر سیٹ اپ کریں
3. ایک سادہ روبوٹ ماڈل بنائیں اور جیزبو میں اس کی سیمولیشن کریں
4. ایک بنیادی ROS 2 نوڈ کو اپنے سیمولیشن ماحول سے جوڑیں
5. سیمولیشن بمقابلہ نظریاتی حسابات میں ایک سادہ سسٹم کے رویے کا موازنہ کریں

## حوالہ جات

- [جیزبو سیمولیشن دستاویزات](http://gazebosim.org/)
- [یونیٹی روبوٹکس ہب](https://github.com/Unity-Technologies/Unity-Robotics-Hub)
- [ROS 2 سیمولیشن ٹیوٹوریلز](https://docs.ros.org/en/humble/Tutorials/Advanced/Simulation.html)
- [روبوٹکس میں فزکس سیمولیشن](https://www.springer.com/gp/book/9783319915624)
- [ڈیجیٹل ٹوئن ٹیکنالوجیز](https://www.sciencedirect.com/science/article/pii/S0166361519302588)