---
title: "چیپٹر 2: ROS 2 مواصلت کے نمونے"
sidebar_label: "چیپٹر 2: ROS 2 مواصلت کے نمونے"
---

# چیپٹر 2: ROS 2 مواصلت کے نمونے

## جائزہ

یہ چیپٹر ROS 2 کے بنیادی مواصلت کے میکانزمز میں گہرائی سے جاتا ہے: ٹاپکس، سروسز، اور ایکشنز۔ ہم یہ جائزہ لیں گے کہ یہ مواصلت کے نمونے روبوٹک سسٹم میں نوڈس کے درمیان مختلف قسم کی بات چیت کو کیسے فعال کرتے ہیں۔ ان نمونوں کو سمجھنا مؤثر روبوٹک معماریوں کو ڈیزائن کرنے کے لیے انتہائی ضروری ہے، خاص طور پر ہیومنوائڈ روبوٹس کے لیے جن کو منسق کردہ احساس، منصوبہ بندی، اور کنٹرول کی ضرورت ہوتی ہے۔ آپ سیکھیں گے کہ ہر نمونے کو کب استعمال کرنا ہے اور اپنی روبوٹک ایپلی کیشنز میں ان کو مؤثر طریقے سے کیسے نافذ کرنا ہے۔

ROS 2 میں مواصلت تین بنیادی نمونوں کے گرد تعمیر کی گئی ہے جو مختلف مقاصد کے لیے کام کرتے ہیں: ٹاپکس غیر ہم وقت ڈیٹا سٹریمنگ کے لیے، سروسز ہم وقت درخواست-جواب کی بات چیت کے لیے، اور ایکشنز ہدف کے مطابق کاموں کے لیے فیڈ بیک کے ساتھ۔ ہر نمونے کے اپنے استعمال کے معاملات اور خصوصیات ہیں جو ان کو مختلف قسم کی روبوٹ مواصلت کی ضروریات کے لیے مناسب بناتے ہیں۔

## سیکھنے کے اہداف

- ROS 2 میں تین بنیادی مواصلت کے نمونے ماسٹر کریں: ٹاپکس، سروسز، اور ایکشنز
- ہر مواصلت کے نمونے کے مناسب استعمال کے معاملات کو سمجھیں
- ٹاپک-مبنی مواصلت کے لیے شائع کنندہ اور سبسکرائبر نوڈس نافذ کریں
- درخواست-جواب مواصلت کے لیے سروس سرورز اور کلائنٹس تیار کریں
- ہدف کے مطابق کاموں کے لیے ایکشن سرورز اور کلائنٹس تیار کریں
- مختلف مواصلت کی ضروریات کے لیے مطابقت پذیر سروس کی معیار (QoS) ترتیبات کا اطلاق کریں

## کلیدی تصورات

### ٹاپکس (شائع کرنا-سبسکرائب کرنا)

ٹاپکس ایک غیر ہم وقت، کئی سے کئی مواصلت کا نمونہ نافذ کرتے ہیں جہاں شائع کنندہ نامزد ٹاپکس پر پیغامات بھیجتے ہیں اور سبسکرائبرز ان ٹاپکس سے پیغامات وصول کرتے ہیں۔ یہ کمزور جوڑائی نظام کو لچکدار ڈیزائن کی اجازت دیتا ہے جہاں شائع کنندہ اور سبسکرائبرز کو ایک دوسرے کے بارے میں جاننے کی ضرورت نہیں ہوتی۔

### سروسز (درخواست-جواب)

سروسز ہم وقت مواصلت فراہم کرتی ہے جہاں ایک کلائنٹ ایک سرور کو ایک درخواست بھیجتا ہے اور ایک جواب کا انتظار کرتا ہے۔ یہ نمونہ ان کاموں کے لیے مناسب ہے جن کو فوری نتائج کی ضرورت ہوتی ہے یا نوڈس کے درمیان ریموٹ طریقہ کالز کے لیے۔

### ایکشنز (ہدف کے مطابق)

ایکشنز طویل چلنے والے کاموں کے لیے ڈیزائن کیے گئے ہیں جن کو ہدف کی ترتیب، انجام کے دوران فیڈ بیک، اور حتمی نتائج کی ضرورت ہوتی ہے۔ وہ نیوی گیشن، مینوپولیشن، یا کسی بھی ایسے کام کے لیے بہترین ہیں جو مکمل ہونے میں وقت لگتا ہے اور نگرانی کی ضرورت ہوتی ہے۔

### سروس کی معیار (QoS) پالیسیز

QoS پالیسیز ہر نمونے کے لیے مواصلت کے رویے کو باریکی سے ایڈجسٹ کرنے کی اجازت دیتی ہیں، قابل اعتمادی، م durable، تاریخ، ڈیڈ لائنز، اور لائیو لینس کے لیے ضروریات کی وضاحت کرتے ہوئے تاکہ مختلف روبوٹک ایپلی کیشنز کی ضروریات کو میل کھاتا ہو۔

## تکنیکی گہرائی

### ٹاپک مواصلت

ROS 2 میں ٹاپکس ایک شائع کرنا-سبسکرائب کا نمونہ استعمال کرتے ہیں جہاں ڈیٹا نامزد چینلز کے ذریعے شائع کنندہ سے سبسکرائبرز تک جاتا ہے۔ یہ نمونہ سینسر ڈیٹا کی تقسیم، روبوٹ کی حالت کا اشتہار، اور دیگر منظار کے لیے مناسب ہے جہاں ڈیٹا کو متعدد دلچسپی رکھنے والے افراد کے ساتھ شیئر کرنے کی ضرورت ہوتی ہے۔

**ٹاپک کی خصوصیات:**

- غیر ہم وقت: شائع کنندہ سبسکرائبرز کا انتظار نہیں کرتا
- کئی سے کئی: متعدد شائع کنندہ اور سبسکرائبرز ایک ہی ٹاپک کا استعمال کر سکتے ہیں
- ڈیٹا-مبنی: مواصلت ڈیٹا کی دستیابی سے ہوتی ہے
- بے حالت: پچھلی بات چیت کا کوئی یاد نہیں رہتا

**ٹاپکس کے لیے QoS ترتیبات:**

- **قابل اعتمادی**: قابل اعتماد (تمام پیغامات ترسیل ہوتے ہیں) یا بہترین کوشش (پیغامات گر سکتے ہیں)
- **م durable**: معدنی (دیر سے شامل ہونے والے سبسکرائبرز ڈیٹا سے محروم ہوتے ہیں) یا عارضی-مقامی (تاریخی ڈیٹا دستیاب ہے)
- **تاریخ**: سب کچھ رکھیں (تمام پیغامات محفوظ کریں) یا آخری رکھیں (صرف حالیہ پیغامات محفوظ کریں)
- **گہرائی**: آخری رکھنے کے استعمال کے دوران محفوظ کرنے کے لیے پیغامات کی تعداد

### سروس مواصلت

سروسز ہم وقت درخواست-جواب مواصلت نافذ کرتی ہے۔ ایک سروس کلائنٹ ایک سروس سرور کو ایک درخواست بھیجتا ہے، جو درخواست کو پروسیس کرتا ہے اور ایک جواب لوٹاتا ہے۔ یہ نمونہ ان کاموں کے لیے مناسب ہے جن کو فوری نتائج کی ضرورت ہوتی ہے۔

**سروس کی خصوصیات:**

- ہم وقت: کلائنٹ سرور کے جواب کا انتظار کرتا ہے
- ایک سے ایک: ایک کلائنٹ ایک وقت میں ایک سرور کے ساتھ بات چیت کرتا ہے
- درخواست-جواب: متعینہ ان پٹس اور آؤٹ پٹس کے ساتھ منظم مواصلت
- حالت دار: سرور درخواستوں کے درمیان حالت برقرار رکھ سکتا ہے

**سروس پیغام کی ساخت:**

- درخواست: کلائنٹ سے سرور تک بھیجا گیا ڈیٹا
- جواب: سرور سے کلائنٹ تک بھیجا گیا ڈیٹا
- .srv فائلز میں وضاحت کی گئی جہاں درخواست اور جواب کے حصے ہوتے ہیں

### ایکشن مواصلت

ایکشنز طویل چلنے والے کاموں کے لیے ڈیزائن کیے گئے ہیں جن کو مکمل ہونے میں قابل ذکر وقت لگ سکتا ہے۔ وہ ہدف کی ترتیب، انجام کے دوران فیڈ بیک، اور نتیجہ رپورٹنگ فراہم کرتے ہیں۔

**ایکشن کی خصوصیات:**

- ہدف کے مطابق: کلائنٹ سرور کو ایک ہدف بھیجتا ہے
- فیڈ بیک: سرور ترقی کے بارے میں مسلسل اپ ڈیٹس فراہم کرتا ہے
- نتیجہ: سرور مکمل ہونے پر حتمی نتیجہ بھیجتا ہے
- منسوخ کرنا ممکن: کاموں کو درمیان میں منسوخ کیا جا سکتا ہے
- منفرد ID: متعدد ہم وقت ہدف کو ٹریک کیا جا سکتا ہے

**ایکشن پیغام کی ساخت:**

- ہدف: کلائنٹ سے سرور تک بھیجا گیا درخواست
- فیڈ بیک: سرور سے کلائنٹ تک مسلسل اپ ڈیٹس
- نتیجہ: سرور سے کلائنٹ تک حتمی نتیجہ

### مواصلت کے نمونے کا موازنہ (متن ڈائیگرام)

```
ٹاپکس (شائع کرنا-سبسکرائب کرنا):
شائع کنندہ نوڈ A         ٹاپک بس         سبسکرائبر نوڈ B
     |------------------->|------------------->|
     |                    |                    |
     | (sensor_data)      | (sensor_data)      | (ڈیٹا کو پروسیس کرتا ہے)
     |                    |                    |
     v                    v                    v
  [ڈیٹا سٹریم]      [ROS 2 مڈل ویئر]    [ڈیٹا پروسیسنگ]

سروسز (درخواست-جواب):
کلائنٹ نوڈ A            سروس بس          سرور نوڈ B
     |------------------->|------------------->|
     | درخواست            | درخواست            | پروسیس
     |<-------------------|<-------------------|
     | جواب           | جواب           | جواب
     |<-------------------|<-------------------|
     | (نتیجہ وصول کرتا ہے)  |                    | (نتیجہ بھیجتا ہے)

ایکشنز (ہدف کے مطابق):
کلائنٹ نوڈ A            ایکشن سرور        سرور نوڈ C
     |------------------->|------------------->|
     | ہدف               | ہدف               | انجام دیں
     |                    |                    | کام
     |<-------------------|<-------------------|
     | فیڈ بیک           | فیڈ بیک           | بھیجیں
     |                    |                    | ترقی
     |<-------------------|<-------------------|
     | نتیجہ             | نتیجہ             | مکمل
```

## کوڈ کی مثالیں

### ٹاپک شائع کنندہ اور سبسکرائبر کی مثال

شائع کنندہ نوڈ:

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from sensor_msgs.msg import LaserScan
import math

class SensorPublisher(Node):

    def __init__(self):
        super().__init__('sensor_publisher')

        # سینسر ڈیٹا کے لیے شائع کنندہ بنائیں
        self.publisher_ = self.create_publisher(LaserScan, 'laser_scan', 10)

        # ڈیٹا کو مسلسل شائع کرنے کے لیے ٹائمر بنائیں
        self.timer = self.create_timer(0.1, self.publish_sensor_data)

        # سینسر ڈیٹا کی شبیہ سازی کریں
        self.angle = 0.0

    def publish_sensor_data(self):
        msg = LaserScan()

        # لیزر اسکین پیرامیٹرز سیٹ کریں
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = 'laser_frame'
        msg.angle_min = -math.pi / 2
        msg.angle_max = math.pi / 2
        msg.angle_increment = math.pi / 180  # 1 ڈگری
        msg.time_increment = 0.0
        msg.scan_time = 0.1
        msg.range_min = 0.1
        msg.range_max = 10.0

        # شبیہ سازی شدہ رینج ڈیٹا بنائیں
        num_readings = int((msg.angle_max - msg.angle_min) / msg.angle_increment) + 1
        msg.ranges = [2.0 + 0.5 * math.sin(self.angle + i * 0.1) for i in range(num_readings)]

        self.publisher_.publish(msg)
        self.get_logger().info(f'{len(msg.ranges)} پڑھائیوں کے ساتھ لیزر اسکین شائع کیا گیا')
        self.angle += 0.01

def main(args=None):
    rclpy.init(args=args)
    sensor_publisher = SensorPublisher()
    rclpy.spin(sensor_publisher)
    sensor_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

سبسکرائبر نوڈ:

```python
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan
import numpy as np

class ObstacleDetector(Node):

    def __init__(self):
        super().__init__('obstacle_detector')

        # لیزر اسکین ٹاپک کے لیے سبسکرپشن بنائیں
        self.subscription = self.create_subscription(
            LaserScan,
            'laser_scan',
            self.scan_callback,
            10)  # QoS پروفائل
        self.subscription  # غیر استعمال شدہ متغیر کی وارننگ کو روکنے کے لیے

    def scan_callback(self, msg):
        # رکاوٹوں کو پہچاننے کے لیے لیزر اسکین ڈیٹا کو پروسیس کریں
        valid_ranges = [r for r in msg.ranges if msg.range_min <= r <= msg.range_max]

        if valid_ranges:
            min_distance = min(valid_ranges)
            self.get_logger().info(f'کم از کم رکاوٹ کی دوری: {min_distance:.2f}م')

            # قریبی رکاوٹوں کی جانچ کریں
            if min_distance < 1.0:
                self.get_logger().warn('رکاوٹ کا پتہ چلا - بہت قریب!')

                # یہاں ہنگامی سٹاپ یا نیوی گیشن منصوبہ بندی کو متحرک کر سکتا ہے
                self.handle_obstacle_detected(min_distance)

    def handle_obstacle_detected(self, distance):
        # رکاوٹ کے سامنے کارروائی کے لیے جگہ کا پتہ چلا دیں
        self.get_logger().info(f'رکاوٹ سے بچاؤ کا آغاز فاصلے کے لیے: {distance:.2f}م')

def main(args=None):
    rclpy.init(args=args)
    obstacle_detector = ObstacleDetector()
    rclpy.spin(obstacle_detector)
    obstacle_detector.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### سروس کی مثال

سروس کی وضاحت (ایک .srv فائل میں):

```
# AddTwoInts.srv
int64 a
int64 b
---
int64 sum
```

سروس سرور:

```python
from example_interfaces.srv import AddTwoInts
import rclpy
from rclpy.node import Node

class MinimalService(Node):

    def __init__(self):
        super().__init__('minimal_service')
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info(f'واپسی: {request.a} + {request.b} = {response.sum}')
        return response

def main(args=None):
    rclpy.init(args=args)
    minimal_service = MinimalService()
    rclpy.spin(minimal_service)
    minimal_service.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

سروس کلائنٹ:

```python
from example_interfaces.srv import AddTwoInts
import rclpy
from rclpy.node import Node

class MinimalClient(Node):

    def __init__(self):
        super().__init__('minimal_client')
        self.cli = self.create_client(AddTwoInts, 'add_two_ints')
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('سروس دستیاب نہیں، دوبارہ انتظار...')
        self.req = AddTwoInts.Request()

    def send_request(self, a, b):
        self.req.a = a
        self.req.b = b
        self.future = self.cli.call_async(self.req)
        rclpy.spin_until_future_complete(self, self.future)
        return self.future.result()

def main(args=None):
    rclpy.init(args=args)
    minimal_client = MinimalClient()
    response = minimal_client.send_request(1, 2)
    minimal_client.get_logger().info(f'نتیجہ: {response.sum}')
    minimal_client.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## عام مسائل

- **ٹاپک QoS عدم مطابقت**: غیر مطابقت پذیر QoS ترتیبات والے شائع کنندہ اور سبسکرائبرز بات چیت نہیں کریں گے۔ ہمیشہ قابل اعتماد مواصلت کے لیے مطابقت پذیر پالیسیز کو یقینی بنائیں۔
- **سروس بلاکنگ**: سروس کالز کالنگ تھریڈ کو بلاک کر دیتے ہیں؛ ہم وقت کالز کو ممکن ہونے پر استعمال کریں تاکہ بنیادی ایکزیکیوشن فلو کو بلاک ہونے سے بچایا جا سکے۔
- **ایکشن ہدف کے تنازعات**: متعدد ایکشن کلائنٹ ایک دوسرے کو متداخل کر سکتے ہیں اگر منفرد ہدف ID کے ساتھ مناسب طریقے سے منظم نہ کیا گیا ہو۔
- **میموری لیکس**: نوڈس اور شائع کنندہ/سبسکرائبرز کو مناسب طریقے سے تباہ کرنا بھولنا طویل چلنے والے سسٹم میں ریسورس لیکس کا سبب بن سکتا ہے۔
- **نیٹ ورک دریافت**: نیٹ ورک کی ترتیب کے مسائل یا مختلف DDS ایمپلیمنٹیشنز کی وجہ سے نوڈس ایک دوسرے کو دریافت نہیں کر سکتے۔

## چیک پوائنٹس / مینی ایکسائزز

1. ایک ٹاپک شائع کنندہ بنائیں جو روبوٹ جوائنٹ اسٹیٹس کا اشتہار دیتا ہے اور ایک سبسکرائبر جو ڈیٹا کو لاگ کرتا ہے
2. ایک سروس نافذ کریں جو دو 3D نقاط کے درمیان یوکلڈین فاصلہ کا حساب لگاتی ہے
3. ایک ایکشن سرور ڈیزائن کریں جو ہدف کی پوزیشن پر روبوٹ کے حرکت کی شبیہ سازی کرتا ہے فیڈ بیک کے ساتھ
4. ایک زیادہ فریکوئنسی سینسر ٹاپک بمقابلہ ایک کم فریکوئنسی کمانڈ ٹاپک کے لیے مختلف QoS ترتیبات کنفیگر کریں
5. ایک لاؤنچ فائل بنائیں جو مختلف QoS کنفیگریشنز کے ساتھ متعدد شائع کنندہ/سبسکرائبر جوڑے شروع کرتی ہے

## حوالہ جات

- [ROS 2 مواصلت کے نمونے](https://docs.ros.org/en/humble/Concepts/About-Topics-Services-Actions.html)
- [ROS 2 میں سروس کی معیار](https://docs.ros.org/en/humble/Concepts/About-Quality-of-Service-settings.html)
- [ROS 2 سروسز ٹیوٹوریل](https://docs.ros.org/en/humble/Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Service-And-Client.html)
- [ROS 2 ایکشنز ٹیوٹوریل](https://docs.ros.org/en/humble/Tutorials/Beginner-Client-Libraries/Using-Actions-In-Python.html)